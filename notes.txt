C++ compilers -
1. GCC - GNU Compiler Collection
2. MinGW - Minimalist GNU for Windows
3. MSVC - Microsoft Visual C++
4. Clang


std::regex_match only returns true when the entire input sequence has been matched, while std::regex_search will succeed even if only a sub-sequence matches the regex.


Regex matching for alphanuneric string - 
--   "^[a-zA-Z0-9]*$"

^ : start of string
[ : beginning of character group
a-z : any lowercase letter
A-Z : any uppercase letter
0-9 : any digit
] : end of character group
* : zero or more of the given characters
$ : end of string

Define base regex - const regex base_regex("^[a-zA-Z]*$");

To get ASCII value of a character - cast it to int
65- 90 --> A-Z
97--122 --> a-z


header - <bits/stdc++.h>

Template class syntax - 

template <typename T>
class vector {
};


Template function syntax - 
template <class T>
T GetMax(const& T a, const& T b) {
	a < b ? return b : return a;
}


Using the mutable keyword as storage class specifier, the object can be modified within a const function

To make a pointer constant, we have to put the const keyword to the right of the *.
Other wise the pointer is a pointer to a const variable.


*i = 10;  will give compile error if const int* i;
but i = &j;
j++ will not;


DATA TYPE	         SIZE (IN BYTES)	RANGE
SHORT INT	              2	           -32,768 TO 32,767
UNSIGNED SHORT INT	      2	            0 TO 65,535
UNSIGNED INT	              4	            0 TO 4,294,967,295
INT	                      4	           -2,147,483,648 TO 2,147,483,647
LONG INT	              8	           -2,147,483,648 TO 2,147,483,647
UNSIGNED LONG INT	      8	           
LONG LONG INT	              8	           -(2^63) TO (2^63)-1
UNSIGNED LONG LONG INT	      8	            0 TO 18,446,744,073,709,551,615
SIGNED CHAR	              1	           -128 TO 127
UNSIGNED CHAR	              1             0 TO 255
float                         4
double                        8
long double                  12
wchar_t                    2 or 4

short/long/ + signed/unsigned --> int    signed/unsigned  ---> char
1 byte = 8 bits


Types of smart pointers - 
1. unique_ptr - only one pointer can point to the object pointed at by unique pointer. 
make_unique, move

2. shared_ptr - allows multiple pointers to point to object being pointed at. 
Maintains a reference count
make_shared, use_count()

3. weak_ptr - same as shared_ptr. Does not maintain a reference count,


explicit keyword prevents the compiler from implicit conversions during constructor call

Syntax for move contructor -- 
className(toObject && fromObject) {};



To detect memory leaks - 
#include <crtdbg.h>
CrtDumpMemoryLeaks();

Assertions - 
1. header - C- assert.h, C++ - cassert
Assertions are used to during debugging/development


Types of pre-processor directives - (processed before compilation)
1. Macro - #define
- Can be used to define variables or functions
#define AREA(l, b) (l * b)  - replaces expression in first bracket with that in second
#define LIMIT 5
2. Inclusion - #include
3. Conditional compilation 
- #ifdef #endif, #ifndef
- #undef - use to undefine a macro
- #pragma - compiler dependent usage
If the replacement text for a macro or symbolic constant is longer than the remainder of the line, a backslash (\) must be placed at the end of the line indicating that the replacement text continues on the next line.  For example:

#define    RECTANGLE_AREA(p, q)  \
(p)*(q)

You use macro - #ifndef--------- #endif in  header files to avoid multilple inclusion


Lock free multithreading using atomic operations
- Atomic operations 
  1. Load/Store
  2. Read, Modify, Write
     - Increment/Decrement, Compare and swap, ..

Mutex vs Semaphore - 
Mutex can be signalled only by the thread that called wait, semaphore can be signalled by other thread


Since 0 is a legal address, assigning (void *)0 to a void* pointer type is fine.

Atomic operations - 

An operation acting on shared memory is atomic if it completes in a single step relative to other threads.
Atomic operations -
1. Load/Store
2. Read,Modify,Write - Increment, Decrement, Compare and Swap, etc.

-- ABA problem in lock free stack implementation
 - solution main pop count 

Virtual Inheritance is the solution to the diamond problem in inheritance, it creates only one copy of the parent in the grandchild. 


When a dervied class pointer points to object of base class, if the destructor of base class is not virtual, only base class destructor is called.

Explicit keyword prevents type conversion during object construction

pragma once - faster than 
#ifndef #define--------- #endif


Virtual tables - creates a table for virtual functions in base and derived classes
when pointer of base type points to object of derived type --> 
and derived class overrides virtual function a() from base -->
when baspointer = & derviedObject
basePointer --> a() ---> will call the overridden method by checking the value of object being pointed at and fetching value from vtable
How does this work ? 
-- When a function is made virtual, in the object space of base and derived objects a pointer (vfptr) is created instead of address of the actual function
-- In the virtual table vfptr points to correct function based on object type instead of pointer type.


void* -- > used in cases where pointer can type to different data types --> generic methods

Difference between --> 
HashMap
HashTable
LinkedHashMap
TreeMap


Lowest common ancestor of 2 nodes - 
compare data at each node with values you are looking for -->
if node value is greater than both -- go left
else go right
when both conditions are false --> the node you are at is the common ancestor

To find size of an array - 
int size = sizeof(arr) / sizeof(arr[0]);

Late Binding - derived object has a vptr -->pointing to the corresponding function in dervied class in virtual table


Sorting algos - 

1. MergeSort
   mergeSort(arr, left, right) {
      if(left>=right) return
      middle = left+right-1/2
      mergeSort(arr, left, middle)
      mergeSort(arr, middle+1, right)
      merge(arr,left, middle,right)
   }

   merge(arr, left, middle right) {
      n1 = middle-left+1
      n2 = middle-right
      
      leftarray (left----n1)
      rightarray(middle+1-----n2)

      i=0,j=0,k=left

      while(i=0 && j=0)
        if(left[i] < right[j]
            array[k] = left[i], i++
        else
            array[k] = right[j], j++
	k++

      while(i < n1) --> arr[k] = left[i] i++ k++
      while(j < n2) --> arr[k] = right[j] j++ k++
   }


2. Selection Sort -
   replace top element with lowest in remaining array

3. Bubble Sort - 
 for i = 0 to i = size - 1
   for j = 0 to j = size - i - 1
      if( arr[j] > arr [j+1]) swap

-- Bubbles out the highest element and keeps reducing the size of array to sort from the end

  
4. Insertion Sort - 

Insert the lowest element in the current iteration at the current position
10 9 5 1 3

---> at i = 1
9 10 5 1 3

--> i = 2
5 9 10 1 3



5. Quick Sort

6. Heap Sort


------------------------------------------------------------------------

Padding and packing - 
#pragma pack(8) --> Default
Can take values 1, 2, 4, 8
"wordsize" is 4 bytes for 32 bit machine and 8 bytes for 64 bit machine


.dll, .so --> dynamic libraries for windows and linux respectively
.lib, .a  --> static libraries for windows and linux respectively


1. .i file is created after preprocessing
2. .s file is created after compiling 
3. .o file is created after assembling
4. .exe is created on linking ( static libraries are loaded)
5.  dynamic libraries are loaded during execution



TODO - 

Multithreading :
Read and implement the following - 
https://www.educative.io/blog/modern-multithreading-and-concurrency-in-cpp
https://www.educative.io/blog/top-five-concurrency-interview-questions-for-software-engineers
https://www.educative.io/blog/multithreading-and-concurrency-fundamentals

Implement one lock free data structure
